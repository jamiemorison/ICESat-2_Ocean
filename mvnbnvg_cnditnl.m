function y=mvnbnvg_cnditnl(x,qualx,quallim,nptsb)% x is series of heights (dots)% qualx is series of sign_conf signal confidence% quallim % derived from mvnbnvg (function y=mvnbnvg(x,nptsb,nptsmv)), Here nptmv will% always equal one. The average will include points  % conditioned on the corresponding qualx >= quallim% use nptsb an odd number to make the average symetric about the center bin% Jamie Morison 7/2/2019%% function y=mvnbnvg(x,nptsb,nptsmv)% mm=0;% [m,n]=size(x);% if m==1,x=x';[m,n]=size(x);mm=1;end% nbins=floor((m-nptsb)/nptsmv)+1;% y=zeros(nbins,n);% % ifrst=0;%  for ibin=1:nbins%        %        y(ibin,1:n)=sum(x((ibin-1)*nptsmv+1:(ibin-1)*nptsmv+nptsb,1:n))/nptsb;%         %   end% if mm==1,y=y';endmm=0;[m,n]=size(x);% Convert x and qualx to column vectors,if m==1,x=x';[m,n]=size(x);qualx=qualx';mm=1;endnbins=floor(m-nptsb)+1;y=zeros(nbins,n);% first mark unqualified photons as NaNx(qualx<quallim,:)=NaN;% Average qualified x's in nptsb grouops centered on ibin for ibin=1:nbins       xx=x((ibin-1)+1:(ibin-1)+nptsb,1:n);             y(ibin,1:n)=mean(xx(~isnan(xx))); end % pad the first (nptsb-1)/2 points and last (nptsb-1)/2 of y % to make it dimensionally identical to xy=[ones((nptsb-1)/2,1)*y(1,:);y;ones((nptsb-1)/2,1)*y(end,:)];   if mm==1  y=y';end%CHECK% x =    1     2     3     4     5     6     7     8     9    10    11% % qual =     4     3     2     1     4     3     2     1     4     3     1% % y=mvnbnvg_cnditnl(x,qual,2,3)% % y = 2.0000    2.0000    2.5000    4.0000    5.5000    6.0000    6.5000    8.0000%     9.5000    9.5000    9.5000%%CORRECT